#!/usr/bin/env python
#   -*- coding: utf-8 -*-

from setuptools import setup
from setuptools.command.install import install as _install

class install(_install):
    def pre_install_script(self):
        pass

    def post_install_script(self):
        pass

    def run(self):
        self.pre_install_script()

        _install.run(self)

        self.post_install_script()

if __name__ == '__main__':
    setup(
        name = 'mppbar',
        version = '0.1.0',
        description = 'A multi-processing enabled progress bar.',
        long_description = '# mppbar\n[![build](https://github.com/soda480/mppbar/actions/workflows/main.yml/badge.svg)](https://github.com/soda480/mppbar/actions/workflows/main.yml)\n[![Code Grade](https://api.codiga.io/project/33815/status/svg)](https://app.codiga.io/public/project/33815/mppbar/dashboard)\n[![vulnerabilities](https://img.shields.io/badge/vulnerabilities-None-brightgreen)](https://pypi.org/project/bandit/)\n[![PyPI version](https://badge.fury.io/py/mppbar.svg)](https://badge.fury.io/py/mppbar)\n[![python](https://img.shields.io/badge/python-3.9-teal)](https://www.python.org/downloads/)\n\nThe mppbar module provides a convenient way to scale execution of a function across multiple input values by distributing the input across a specified number of background processes, it displays the execution status of each background process using a progress bar; the MPpbar class is a subclass of [MPmq](https://github.com/soda480/mpmq). The main benefit of using `mppbar` is the target function requires only minimal modification (if at all). The progress bar will be setup and determined by inspecting the log messages that generated by your function, thus implementing logging is the only requirement of the target function.\n\n### Installation\n```bash\npip install mppbar\n```\n\n### `MPpbar class`\n```\nMPpbar(function, process_data=None, shared_data=None, processes_to_start=None, regex=None, fill=None)\n```\n> `function` - The function to execute. It should accept two positional arguments; the first argument is the dictionary created for the respective process see `process_data` below, the second argument is the shared dictionary sent to all proceses see `shared_data` below.\n\n> `process_data` - A list of dictionaries where each dictionary describes the input data that will be sent to the respective background process executing the function; the length of the list dictates the total number of processes that will be executed.\n\n> `shared_data` - A dictionary containing arbitrary data that will be sent to all processes.\n\n> `processes_to_start` - The number of processes to initially start; this represents the number of concurrent processes that will be running. If the total number of processes is greater than this \nnumber then execution will be queued and executed to ensure that this concurrency is maintained. Defaults to the length of the `process_data` lsit.\n\n> `regex` - A dictionary whose key values are regular expressions for `total`, `count` and `alias`. The regular expressions will be checked against the log messages generated by the executing function, if matched will be used to assign the attributes for the respective progress bar. The `total` and `count` key values are required, the `alias` key value is optional.\n\n> `fill` - A dictionary whose key values are integers that dictate the number of leading zeros the progress bar should add to the `total`, `index` and `completed` values; this is optional and should be used to format the progress bar appearance. The supported key values are `max_total`, `max_index` and `max_completed`.\n\n> **execute(raise_if_error=False)**\n>> Start execution the processâ€™s activity. If `raise_if_error` is set to True, an exception will be raised if any function encountered an error during execution.\n\n\n### Examples\n\n#### [example1](https://github.com/soda480/mppbar/blob/main/examples/example1.py)\n\nDistribute work across multiple processes executing concurrently and each displays a progress bar showing its execution status.\n\n<details><summary>Code</summary>\n\n```Python\nfrom mppbar import MPpbar\nimport time, names, random, logging\nlogger = logging.getLogger(__name__)\n\ndef do_work(data, *args):\n    logger.debug(f\'processor is {names.get_last_name()}\')\n    total = data[\'total\']\n    logger.debug(f\'processing total of {total}\')\n    for index in range(total):\n        time.sleep(random.choice([.1, .2, .4]))\n        logger.debug(f\'processed item {index}\')\n    return total\n\ndef main():\n    process_data = [{\'total\': random.randint(8, 16)} for item in range(6)]\n    regex = {\n        \'total\': r\'^processing total of (?P<value>\\d+)$\',\n        \'count\': r\'^processed item \\d+$\',\n        \'alias\': r\'^processor is (?P<value>.*)$\',\n    }\n    print(\'>> Processing items...\')\n    pbars =  MPpbar(function=do_work, process_data=process_data, regex=regex, timeout=1)\n    results = pbars.execute()\n    print(f">> {len(process_data)} workers processed a total of {sum(result for result in results)} items")\n\nif __name__ == \'__main__\':\n    main()\n```\n</details>\n\n![example1](https://raw.githubusercontent.com/soda480/mppbar/main/docs/images/example1.gif)\n\n#### [example2](https://github.com/soda480/mppbar/blob/main/examples/example2.py)\n\nDistribute work across multiple processes but only a subset are executing concurrently and each displays a progress bar showing its execution status. Useful if you can only afford to run a few background processes concurrently.\n\n<details><summary>Code</summary>\n\n```Python\nfrom mppbar import MPpbar\nimport time, names, random, logging\nlogger = logging.getLogger(__name__)\n\ndef do_work(data, *args):\n    logger.debug(f\'processor is {names.get_last_name()}\')\n    total = data[\'total\']\n    logger.debug(f\'processing total of {total}\')\n    for index in range(total):\n        time.sleep(random.choice([.1, .2, .4]))\n        logger.debug(f\'processed item {index}\')\n    return total\n\ndef main():\n    process_data = [{\'total\': random.randint(8, 16)} for item in range(6)]\n    regex = {\n        \'total\': r\'^processing total of (?P<value>\\d+)$\',\n        \'count\': r\'^processed item \\d+$\',\n        \'alias\': r\'^processor is (?P<value>.*)$\',\n    }\n    fill = {\n        \'max_total\': 100\n    }\n    print(\'>> Processing items...\')\n    pbars =  MPpbar(function=do_work, process_data=process_data, regex=regex, fill=fill, processes_to_start=3, timeout=1)\n    results = pbars.execute()\n    print(f">> {len(process_data)} workers processed a total of {sum(result for result in results)} items")\n\nif __name__ == \'__main__\':\n    main()\n```\n</details>\n\n![example2](https://raw.githubusercontent.com/soda480/mppbar/main/docs/images/example2.gif)\n\n#### [example3](https://github.com/soda480/mppbar/blob/main/examples/example3.py)\n\nDistribute alot of work across a small set of processes using a thread-safe queue, each process get work off the queue until there is no more work, all processes reuse a progress bar to show its execution status. Useful if you have alot of data to distribute across a small set of workers.\n\n<details><summary>Code</summary>\n\n```Python\nfrom mppbar import MPpbar\nimport time, names, random, logging\nfrom multiprocessing import Queue\nfrom queue import Empty\nlogger = logging.getLogger(__name__)\n\ndef do_work(total):\n    logger.debug(f\'processor is {names.get_last_name()}\')\n    logger.debug(f\'processing total of {total}\')\n    for index in range(total):\n        time.sleep(random.choice([.001, .003, .005]))\n        logger.debug(f\'processed item {index}\')\n    return total\n\ndef prepare_queue():\n    queue = Queue()\n    for _ in range(100):\n        queue.put({\'total\': random.randint(40, 99)})\n    return queue\n\ndef run_q(data, *args):\n    queue = data[\'queue\']\n    result = 0\n    while True:\n        try:\n            total = queue.get(timeout=1)[\'total\']\n            result += do_work(total)\n            logger.debug(\'reset-mppbar\')\n        except Empty:\n            logger.debug(\'reset-mppbar-complete\')\n            break\n    return result\n\ndef main():\n    queue = prepare_queue()\n    process_data = [{\'queue\': queue} for item in range(3)]\n    regex = {\n        \'total\': r\'^processing total of (?P<value>\\d+)$\',\n        \'count\': r\'^processed item \\d+$\',\n        \'alias\': r\'^processor is (?P<value>.*)$\',\n    }\n    print(\'>> Processing items...\')\n    pbars =  MPpbar(function=run_q, process_data=process_data, regex=regex, timeout=1)\n    results = pbars.execute()\n    print(f">> {len(process_data)} workers processed a total of {sum(result for result in results)} items")\n\nif __name__ == \'__main__\':\n    main()\n```\n</details>\n\n![example3](https://raw.githubusercontent.com/soda480/mppbar/main/docs/images/example3.gif)\n\n\n### Development\n\nClone the repository and ensure the latest version of Docker is installed on your development server.\n\nBuild the Docker image:\n```sh\ndocker image build \\\n-t \\\nmppbar:latest .\n```\n\nRun the Docker container:\n```sh\ndocker container run \\\n--rm \\\n-it \\\n-v $PWD:/code \\\nmppbar:latest \\\n/bin/bash\n```\n\nExecute the build:\n```sh\npyb -X\n```',
        long_description_content_type = 'text/markdown',
        classifiers = [
            'Development Status :: 4 - Beta',
            'Environment :: Console',
            'Environment :: Other Environment',
            'Intended Audience :: Developers',
            'Intended Audience :: System Administrators',
            'License :: OSI Approved :: Apache Software License',
            'Operating System :: POSIX :: Linux',
            'Programming Language :: Python',
            'Programming Language :: Python :: 3.6',
            'Programming Language :: Python :: 3.7',
            'Programming Language :: Python :: 3.8',
            'Programming Language :: Python :: 3.9',
            'Topic :: Software Development :: Libraries',
            'Topic :: Software Development :: Libraries :: Python Modules',
            'Topic :: System :: Networking',
            'Topic :: System :: Systems Administration'
        ],
        keywords = '',

        author = 'Emilio Reyes',
        author_email = 'soda480@gmail.com',
        maintainer = '',
        maintainer_email = '',

        license = 'Apache License, Version 2.0',

        url = 'https://github.com/soda480/mppbar',
        project_urls = {},

        scripts = [],
        packages = ['mppbar'],
        namespace_packages = [],
        py_modules = [],
        entry_points = {},
        data_files = [],
        package_data = {},
        install_requires = [
            'mpmq',
            'cursor',
            'colorama',
            'progress1bar'
        ],
        dependency_links = [],
        zip_safe = True,
        cmdclass = {'install': install},
        python_requires = '',
        obsoletes = [],
    )
