import { S as SvelteComponent, i as init, s as safe_not_equal, f as element, b as attr, t as toggle_class, c as insert, P as update_slot_base, Q as get_all_dirty_from_scope, R as get_slot_changes, v as transition_in, w as transition_out, e as detach, k as empty, T as getContext, U as create_slot } from './index.6155978a.js';
import { g as get_styles } from './styles.db46e346.js';

/* Users/aliabid/projects/gradio/ui/packages/atoms/src/Block.svelte generated by Svelte v3.47.0 */

function create_dynamic_element(ctx) {
	let svelte_element;
	let svelte_element_class_value;
	let svelte_element_style_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[19].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[18], null);

	return {
		c() {
			svelte_element = element(/*tag*/ ctx[12]);
			if (default_slot) default_slot.c();
			attr(svelte_element, "data-testid", /*test_id*/ ctx[5]);
			attr(svelte_element, "id", /*elem_id*/ ctx[0]);

			attr(svelte_element, "class", svelte_element_class_value = "relative w-full overflow-hidden " + /*styles*/ ctx[11][/*variant*/ ctx[1]] + " " + (/*rounded*/ ctx[6]
			? /*styles*/ ctx[11][/*color*/ ctx[2]]
			: '') + " " + /*form_class*/ ctx[10] + " " + /*classes*/ ctx[9] + " " + /*rounded_style*/ ctx[8]);

			attr(svelte_element, "style", svelte_element_style_value = /*size_style*/ ctx[7] || null);
			toggle_class(svelte_element, "gr-panel", /*padding*/ ctx[3]);
			toggle_class(svelte_element, "form", /*form_position*/ ctx[4]);
			toggle_class(svelte_element, "gr-box-unrounded", !/*rounded*/ ctx[6] && /*form_position*/ ctx[4]);
			toggle_class(svelte_element, "gr-box", !/*form_position*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, svelte_element, anchor);

			if (default_slot) {
				default_slot.m(svelte_element, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 262144)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[18],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[18])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[18], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*test_id*/ 32) {
				attr(svelte_element, "data-testid", /*test_id*/ ctx[5]);
			}

			if (!current || dirty & /*elem_id*/ 1) {
				attr(svelte_element, "id", /*elem_id*/ ctx[0]);
			}

			if (!current || dirty & /*variant, rounded, color, form_class, classes, rounded_style*/ 1862 && svelte_element_class_value !== (svelte_element_class_value = "relative w-full overflow-hidden " + /*styles*/ ctx[11][/*variant*/ ctx[1]] + " " + (/*rounded*/ ctx[6]
			? /*styles*/ ctx[11][/*color*/ ctx[2]]
			: '') + " " + /*form_class*/ ctx[10] + " " + /*classes*/ ctx[9] + " " + /*rounded_style*/ ctx[8])) {
				attr(svelte_element, "class", svelte_element_class_value);
			}

			if (!current || dirty & /*size_style*/ 128 && svelte_element_style_value !== (svelte_element_style_value = /*size_style*/ ctx[7] || null)) {
				attr(svelte_element, "style", svelte_element_style_value);
			}

			if (dirty & /*variant, rounded, color, form_class, classes, rounded_style, padding*/ 1870) {
				toggle_class(svelte_element, "gr-panel", /*padding*/ ctx[3]);
			}

			if (dirty & /*variant, rounded, color, form_class, classes, rounded_style, form_position*/ 1878) {
				toggle_class(svelte_element, "form", /*form_position*/ ctx[4]);
			}

			if (dirty & /*variant, rounded, color, form_class, classes, rounded_style, rounded, form_position*/ 1878) {
				toggle_class(svelte_element, "gr-box-unrounded", !/*rounded*/ ctx[6] && /*form_position*/ ctx[4]);
			}

			if (dirty & /*variant, rounded, color, form_class, classes, rounded_style, form_position*/ 1878) {
				toggle_class(svelte_element, "gr-box", !/*form_position*/ ctx[4]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svelte_element);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function create_fragment(ctx) {
	let previous_tag = /*tag*/ ctx[12];
	let svelte_element_anchor;
	let current;
	let svelte_element = /*tag*/ ctx[12] && create_dynamic_element(ctx);

	return {
		c() {
			if (svelte_element) svelte_element.c();
			svelte_element_anchor = empty();
		},
		m(target, anchor) {
			if (svelte_element) svelte_element.m(target, anchor);
			insert(target, svelte_element_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*tag*/ ctx[12]) {
				if (!previous_tag) {
					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else if (safe_not_equal(previous_tag, /*tag*/ ctx[12])) {
					svelte_element.d(1);
					svelte_element = create_dynamic_element(ctx);
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else {
					svelte_element.p(ctx, dirty);
				}
			} else if (previous_tag) {
				svelte_element.d(1);
				svelte_element = null;
			}

			previous_tag = /*tag*/ ctx[12];
		},
		i(local) {
			if (current) return;
			transition_in(svelte_element);
			current = true;
		},
		o(local) {
			transition_out(svelte_element);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(svelte_element_anchor);
			if (svelte_element) svelte_element.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let _parent;
	let form_class;
	let classes;
	let rounded;
	let rounded_style;
	let size_style;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { style = {} } = $$props;
	let { elem_id = "" } = $$props;
	let { variant = "solid" } = $$props;
	let { color = "grey" } = $$props;
	let { padding = true } = $$props;
	let { form_position = undefined } = $$props;
	let { type = "normal" } = $$props;
	let { test_id = undefined } = $$props;
	let { disable = false } = $$props;
	let { explicit_call = false } = $$props;

	const styles = {
		dashed: "border-dashed border border-gray-300",
		solid: "border-solid border",
		grey: "border-gray-200",
		green: "border-green-400",
		none: "!border-0"
	};

	const form_styles = {
		column: {
			first: "rounded-t-lg",
			last: "rounded-b-lg",
			mid: "",
			single: "rounded-lg"
		},
		row: {
			first: "rounded-t-lg md:rounded-t-none md:rounded-l-lg ",
			last: "rounded-b-lg md:rounded-b-none md:rounded-r-lg",
			mid: "",
			single: "rounded-lg"
		}
	};

	let tag = type === "fieldset" ? "fieldset" : "div";
	const parent = getContext("BLOCK_KEY");

	$$self.$$set = $$props => {
		if ('style' in $$props) $$invalidate(13, style = $$props.style);
		if ('elem_id' in $$props) $$invalidate(0, elem_id = $$props.elem_id);
		if ('variant' in $$props) $$invalidate(1, variant = $$props.variant);
		if ('color' in $$props) $$invalidate(2, color = $$props.color);
		if ('padding' in $$props) $$invalidate(3, padding = $$props.padding);
		if ('form_position' in $$props) $$invalidate(4, form_position = $$props.form_position);
		if ('type' in $$props) $$invalidate(14, type = $$props.type);
		if ('test_id' in $$props) $$invalidate(5, test_id = $$props.test_id);
		if ('disable' in $$props) $$invalidate(15, disable = $$props.disable);
		if ('explicit_call' in $$props) $$invalidate(16, explicit_call = $$props.explicit_call);
		if ('$$scope' in $$props) $$invalidate(18, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*form_position, _parent*/ 131088) {
			$$invalidate(10, form_class = form_position
			? form_styles?.[_parent || "column"][form_position]
			: "");
		}

		if ($$self.$$.dirty & /*explicit_call, style, disable*/ 106496) {
			$$invalidate(
				9,
				{ classes } = explicit_call
				? get_styles(style, ["rounded", "border"])
				: disable
					? get_styles({ container: false }, ["container"])
					: { classes: "" },
				classes
			);
		}

		if ($$self.$$.dirty & /*style*/ 8192) {
			$$invalidate(6, rounded = typeof style.rounded !== "boolean" || typeof style.rounded === "boolean" && style.rounded);
		}

		if ($$self.$$.dirty & /*style, rounded*/ 8256) {
			$$invalidate(8, rounded_style = typeof style.rounded === "boolean"
			? get_styles({ rounded }, ["rounded"]).classes
			: "");
		}

		if ($$self.$$.dirty & /*style*/ 8192) {
			$$invalidate(7, size_style = "" + (typeof style.width === "number"
			? `height: ${style.width}px; `
			: "") + (typeof style.width === "number"
			? `width: ${style.width}px;`
			: ""));
		}
	};

	$$invalidate(17, _parent = parent === "column" || parent == "row"
	? parent
	: "column");

	return [
		elem_id,
		variant,
		color,
		padding,
		form_position,
		test_id,
		rounded,
		size_style,
		rounded_style,
		classes,
		form_class,
		styles,
		tag,
		style,
		type,
		disable,
		explicit_call,
		_parent,
		$$scope,
		slots
	];
}

class Block extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			style: 13,
			elem_id: 0,
			variant: 1,
			color: 2,
			padding: 3,
			form_position: 4,
			type: 14,
			test_id: 5,
			disable: 15,
			explicit_call: 16
		});
	}
}

export { Block as B };
