<-operator;


@ Stack {

    create size? * {
        size <> -/;
        'stack: [];
        'size: size;
    }

    push item * {
        ? 'isFull() {
            "stack is full (size " + 'size.toString() + ")"!!!;
        }
        'stack+: [item];
    }

    pushAll items * {
        ... element ->? items {
            'push(element);
        }
    }

    special * {
        * 'stack$;
    }

    pop * {
        ? 'isEmpty() {
            "stack is empty"!!!;
        }
        out: 'stack<<-/>>;
        'stack-: 'stack$ - /;
        * out;
    }

    peek * {
        ? 'isEmpty() {
            "stack is empty"!!!;
        }
        * 'stack<<-/>>;
    }

    toBit * {
        * 'stack$ > \;
    }

    isFull * {
        * 'size :: 'stack$;
    }

    isEmpty * {
        * 'stack$ :: \;
    }

    toString * {
        <-string.wrap;
        <-types.String;
        ?? {
            top: 'peek();
        } !! {
            top: _;
        }
        ? top?! :: String {
            top: wrap(top.toString(), "\"");
        }
        * "Stack(capacity:" + 'size.toString()
        + ", size:" + 'stack$.toString()
        + ", top:" + top.toString()
        + ")";
    }

}

@ Queue {

    create size? * {
        size <> -/;
        'queue: [];
        'size: size;
    }

    special * {
        * 'queue$;
    }

    isEmpty * {
        * ~~ '$;
    }

    isFull * {
        * '$ :: 'size;
    }

    throwEmpty * {
        ? 'isEmpty() {
            "queue is empty"!!!;
        }
    }

    put item * {
        ? 'isFull() {
            "queue is full (size " + 'size.toString() + ")"!!!;
        }
        'queue+: [item];
    }

    putAll items * {
        ... item ->? items {
            'put(item);
        }
    }

    get * {
        'throwEmpty();
        out: 'queue<<\>>;
        'queue-: \;
        * out;
    }

    first * {
        'throwEmpty(); * 'queue<<\>>;
    }
    last * {
        'throwEmpty(); * 'queue<<-/>>;
    }

    toBit * {
        * '$ > \;
    }

    toString * {
        <-string.wrap;
        <-types.String;
        ? '$ <: /\/ {
            items: 'queue.toString();
        } ,, ? '$ > /\/ {
            first: 'first().toString();
            last: 'last().toString();
            ? 'first()?! :: String {
                first: wrap(first, "\"");
            }
            ? 'last()?! :: String {
                last: wrap(last, "\"");
            }
            items: "[" + first.toString() + ", ..., " + last.toString() + "]";
        } ,, {
            items: "[]";
        }
        * "Queue(capacity:" + 'size.toString()
        + ", size:" + 'queue$.toString()
        + ", items:" + items + ")";
    }

}

@ Set {

    create items? capacity? * {
        items <> [];
        capacity <> -/;
        <-iter.find;
        'find: find;
        'items: [i ... i ->? items] ? items ,, [];
        'capacity: capacity;
    }

    special * {
        * 'items$;
    }

    add value * {
        ? ~~ 'has(value) {
            ? 'isFull() {
                "set is full (capacity " + 'capacity.toString() + ")"!!!;
            }
            'items+: [value];
            * /;
        }
        * \;
    }

    toBit * {
        * ~~ 'isEmpty();
    }

    toString * {
        * "Set(capacity:" + 'capacity.toString()
        + ", size:" + '$.toString()
        + ", items:" + 'items.toString()
        + ")";
    }

    remove value * {
        'items-: [value];
    }

    has value * {
        * 'find('items, value) >: \;
    }

    values * {
        * 'items;
    }

    clear * {
        'items: [];
    }

    isEmpty * {
        * '$ :: \;
    }

    isFull * {
        * '$ :: 'capacity;
    }

    newSetSize a b * {
        * a$ ? a$ > b$ ,, b$;
    }

    union other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + other?!.toString()!!!;
        }

        unionSet: Set('values(), 'newSetSize(', other) ++ /\);

        ... value ->? other.values() {
            unionSet.add(value);
        }

        * unionSet;
    }

    intersection other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + other?!.toString()!!!;
        }

        intersectionSet: Set([], 'newSetSize(', other));

        ... value ->? 'values() {
            ? other.has(value) {
                intersectionSet.add(value);
            }
        }

        * intersectionSet;
    }

    difference other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + other?!.toString()!!!;
        }

        differenceSet: Set([], 'newSetSize(', other));

        ... value ->? 'values() {
            ? ~~ other.has(value) {
                differenceSet.add(value);
            }
        }

        * differenceSet;
    }

    isSubset other * {
        ? other?! ::: Set()?! {
            "expected Set, received " + other?!.toString()!!!;
        }

        ? '$ > other$ { * \; }

        ... value ->? 'values() {
            ? ~~ other.has(value) { * \; }
        }
        * /;
    }

}

@ Deque {

    create size? * {
        size <> -/;
        'deque: [];
        'size: size;
    }

    special * {
        * 'deque$;
    }

    isEmpty * {
        * ~~ '$;
    }

    isFull * {
        * '$ :: 'size;
    }

    throwEmpty * {
        ? 'isEmpty() {
            "deque is empty"!!!;
        }
    }

    throwFull * {
        ? 'isFull() {
            "deque is full (size " + 'size.toString() + ")"!!!;
        }
    }

    putFront item * {
        'throwFull(); 'deque: [item] + 'deque;
    }

    put item * {
        'throwFull(); 'deque+: [item];
    }

    putFrontAll items * {
        ... item ->? items {
            'putFront(item);
        }
    }

    putAll items * {
        ... item ->? items {
            'put(item);
        }
    }

    front * {
        * 'deque<<\>>;
    }

    back * {
        * 'deque<<-/>>;
    }

    toBit * {
        * '$ > \;
    }

    getFront * {
        'throwEmpty();
        out: 'deque<<\>>;
        'deque-: \;
        * out;
    }

    get * {
        'throwEmpty();
        out: 'deque<<-/>>;
        'deque-: 'deque$ - /;
        * out;
    }

    toString * {
        <-string.wrap;
        <-types.String;
        ? '$ <: /\/ {
            items: 'deque.toString();
        } ,, ? '$ > /\/ {
            front: 'front().toString();
            back: 'back().toString();
            ? 'front()?! :: String {
                front: wrap(front, "\"");
            }
            ? 'back()?! :: String {
                back: wrap(back, "\"");
            }
            items: "[" + front.toString() + ", ..., " + back.toString() + "]";
        } ,, {
            items: "[]";
        }
        * "Deque(capacity:" + 'size.toString()
        + ", size:" + 'deque$.toString()
        + ", items:" + items + ")";
    }

}

@ StaticArray {

    create value type? * {
        type <> _;
        <-types.Array, Integer;
        ? value?! :: Integer {
            'value: {{}};
            'size: value;
            'type: type;
        } ,, ? value?! :: Array {
            'value: {{}};
            'size: value$;
            'type: type;
            i: \;
            ... e ->? value {
                ? _ ::: type ::: e?! {
                    "expected " + type.toString() + ", found " + e?!.toString()!!!;
                }
                'value<<i>>: e;
                i+: /;
            }
        } ,, {
            "expected Integer or Array, found " + value?!.toString()!!!;
        }
    }

    special * {
        * 'value$;
    }

    toString * {
        * "StaticArray(size:" + 'size.toString()
        + ", type:" + 'type.toString()
        + ", items:" + 'value.toString()
        + ")";
    }

    toBit * {
        * 'value.toBit();
    }

    throwInvalidIndex arg * {
        <-types.Integer;
        ? arg?! ::: Integer {
            "expected Integer, received " + arg?!.toString()!!!;
        }
        ? ~~ (\ <: arg < 'size) {
            "index " + arg.toString() + " is out of bounds (size " + 'size.toString() + ")"!!!;
        }
    }

    throwInvalidType type * {
        ? _ ::: 'type ::: type {
            "expected " + 'type.toString() + ", received " + type.toString()!!!;
        }
    }

    getItem index * {
        'throwInvalidIndex(index);
        * 'value<<index>>;
    }

    setItem index value * {
        'throwInvalidIndex(index);
        'throwInvalidType(value?!);
        'value<<index>>: value;
    }

}

@ ArithmeticArray {

    create array * {
        'array: array;
    }

    apply op other * {
        * ArithmeticArray([op(i, other) ... i ->? 'array]);
    }

    and other * {
        * 'apply(operator.and, other);
    }

    add other * {
        * 'apply(operator.add, other);
    }

    divide other * {
        * 'apply(operator.divide, other);
    }

    equals other * {
        * 'apply(operator.equals, other);
    }

    greaterThanOrEqual other * {
        * 'apply(operator.greaterThanOrEqual, other);
    }

    greaterThan other * {
        * 'apply(operator.greaterThan, other);
    }

    lessThanOrEqual other * {
        * 'apply(operator.lessThanOrEqual, other);
    }

    lessThan other * {
        * 'apply(operator.lessThan, other);
    }

    mod other * {
        * 'apply(operator.mod, other);
    }

    multiply other * {
        * 'apply(operator.multiply, other);
    }

    notEquals other * {
        * 'apply(operator.notEquals, other);
    }

    or other * {
        * 'apply(operator.or, other);
    }

    power other * {
        * 'apply(operator.power, other);
    }

    subtract other * {
        * 'apply(operator.subtract, other);
    }

    xor other * {
        * 'apply(operator.xor, other);
    }

    andAssign other * {
        'array: 'and(other).array; * ';
    }

    addAssign other * {
        'array: 'add(other).array; * ';
    }

    divideAssign other * {
        'array: 'divide(other).array; * ';
    }

    modAssign other * {
        'array: 'mod(other).array; * ';
    }

    multiplyAssign other * {
        'array: 'multiply(other).array; * ';
    }

    orAssign other * {
        'array: 'or(other).array; * ';
    }

    powerAssign other * {
        'array: 'power(other).array; * ';
    }

    subtractAssign other * {
        'array: 'subtract(other).array; * ';
    }

    xorAssign other * {
        'array: 'xor(other).array; * ';
    }

    getItem item * {
        <-types.Array;
        out: 'array<<item>>;
        ? out?! :: Array {
            * ArithmeticArray(out);
        }
        * out;
    }

    setItem item value * {
        'array<<item>>: value;
    }

    special * {
        * 'array$;
    }

    toBit * {
        * 'array.toBit();
    }

    toString * {
        * 'array.toString();
    }

}