# -*- coding: utf-8 -*-
"""data-generation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1C18d5OmxL-vb2iTenazZRlZ6VglaoQTW

**@copyright Akash Sonowal and Dr. Shankar Prawesh**

**"Empirical Asset Pricing via Machine Learning" (2018) and "Autoencoder Asset Pricing Models." (2019)**
"""

#Mounting drive
from google.colab import drive
drive.mount('/content/drive')

#importing libraries
import os
import math
import numpy as np
import pandas as pd

#Creating our directories
path = "/content/drive/MyDrive/IME 699/datasets"
path1 = os.path.join(path,"pc_50")
path2 = os.path.join(path,"pc_100")
try:
  os.makedirs(path1, exist_ok = True)
  os.makedirs(path2, exist_ok = True)
  print("Directories are created successfully")
except OSError as error:
  print("Directories cannot be created due to other OS errors")

"""**The excess return of a (latent) 3-factor model is calculated as:**

$r_{i,t+1} = g^*(z_{i,t}) + e_{i,t+1}$ for t = 1, 2, ..., T and $1\leq i\leq N$

We have to calculate $g^*(z_{i,t})$ and $e_{i,t+1}$ terms to calculate $r_{i,t+1}$ 

Now, $z_{i,t} = (1,x_t)' \otimes c_{i,t}$ represents the Kronecker
product between firm-level characteristics $c_{i,t}$ and time-series common factors $x_t$.

where $c_t$ is the N x $P_c$ matrix of characteristics
"""

N = 200 #No of stocks
T = 180 #No of months

#Flatten Nested LinkedList
def flattenNestedList(nestedList):
    flatList = []
    for elem in nestedList:
        if isinstance(elem, list):
            flatList.extend(flattenNestedList(elem))
        else:
            flatList.append(elem)    
    return flatList
    
#Cross-sectional rank function
def csrankf(arr):
  elements = sorted(set(arr))
  hashMap = {}
  rank = 1
  for element in elements:
    hashMap[element] = rank
    rank += 1
  ranks = []
  for i in arr:
    ranks.append(hashMap[i])
  return np.array(ranks)

"""### $\underline{Case Pc = 50 (Parameter)}$"""

Pc_50 = 50 #No of characteristics or parameters

"""**Step 1: For Calculating $g^*(z_{i,t})$ we need to calculate the below terms**

$z_{i,t} = (1,x_t)' \otimes c_{i,t}$ 

$c_{i,j,t} = \frac{2}{N+1} CSrank(\overline{c}_{i,j,t})-1$

$x_t = \rho x_{t-1} + u_t$

Calculating $c_{i,j,t} = \frac{2}{N+1} CSrank(\overline{c}_{i,j,t})-1$, where $\overline{c}_{i,j,t} = \rho_j \overline{c}_{i,j,t-1} + \epsilon_{i,j,t}$ for $\rho_j\sim U[0.9,1]$ and $\epsilon_{i,j,t}\sim N(0,1-\rho_j^2)$

where $1\leq j\leq P_c$
"""

c_ijt_50 = np.zeros((N*T,Pc_50)) # 36000 x 50; the matrix c_i,j,t
rho_j_50 = np.random.uniform(0.9,1,[Pc_50,1]) # 50 x 1; used in the equation of cbar_i,j,t

#Calculating c_ijt
for j in range(Pc_50):
  cbar_ijt_50 = np.zeros((N,T)) # 200 x 180; cbar_i,j,t
  cbar_ijt_50[:, 0] = np.random.uniform(0,1,N) # cbar_i,j,0 is initialised to values between [0, 1]

  for t in range(1,T):
    cbar_ijt_50[:,t] = rho_j_50[j]*cbar_ijt_50[:,t-1] + np.random.normal(0,1,N)*math.sqrt(1-rho_j_50[j]**2) #filling column wise for all stocks

  cbar_ijt_normal_50 = np.zeros(cbar_ijt_50.shape) # 200 x 180 for the normalised values of the characteristics

  for t in range(cbar_ijt_50.shape[1]): # loop through 180 columns
    cbar_ijt_normal_50[:, t] = 2/(N+1) * csrankf(cbar_ijt_50[:,t].tolist())-1 

  c_ijt_50[:,j] = cbar_ijt_normal_50.flatten('F') #Final characteristic matrix #column wise stacked so for a single time stamp, we get 200 stocks data points

"""Calculating $x_t = \rho x_{t-1} + u_t$ for $\rho$ = 0.95 and $u_t \sim N(0,1-\rho^2)$"""

#calculating xt
rho_50 = 0.95
x_t_50 = np.zeros((T,1)) # 180 x 1; x_t is time series component and is highly persistent
x_t_50[0] = np.random.normal(0,1) #initiated with value between [0, 1]
for t in range(1,T):
  x_t_50[t] = rho_50 * x_t_50[t-1] + np.random.normal(0,1) * math.sqrt(1-rho_50**2)

"""Calculating $z_{i,t} = (1,x_t)' \otimes c_{i,t}$ """

# Calculating characteristics matrix with time series common characteristics, c_x
c_x_50 = c_ijt_50 #36000 x 50
time_50 = np.repeat(np.arange(T), N) #(36000,1) time vector to fill sequentially in time. It looks like [1,2,3...,180,1,2,3...]
for t in range(T):
  idx = (time_50==t) #idx for all stocks observed at same month 
  c_x_50[idx,:] = c_ijt_50[idx, :]*x_t_50[t]

#Equivalent to tensor product, z is:
z_50 = np.hstack((c_ijt_50, c_x_50))

"""Calculating $g^*(z_{i,t})$

**Model 1**: 

$g^*(z_{i,t}) = (c_{i1,t}, c_{i2,t}, c_{i3,t} × x_t ) θ_0$ where $θ_0 = (0.02, 0.02, 0.02)'$
"""

# Calculating theta0
theta_w_50 = 0.02 #used in g* in equation to find return r
theta_nested_50 = [1.0, 1.0, np.repeat(0.0,Pc_50-2).tolist(), 0.0, 0.0, 1.0, np.repeat(0.0,Pc_50-3).tolist()] #1.0 corresponding to 3 factors
theta_50 = np.array(flattenNestedList(theta_nested_50))*theta_w_50
theta_50 = theta_50.reshape(-1,1) # 100 x 1

#Calculating g*
g1_50 = np.dot(z_50,theta_50)

"""**Step 2**: For calculating $e_{i,t+1} = β_{i,t}v_{t+1} + ε_{i,t+1}$

$β_{i,t} = (c_{i1,t}, c_{i2,t}, c_{i3,t})$

$v_{t+1} ∼ N (0,0.05^2 × I_3 )$ is a 3 × 1 vector of factors

$ε_{t+1} ∼ t_5 (0, 0.05^2)$ is a N × 1 vector of idiosyncratic errors
"""

stdv_50 = 0.05 #used in the equation of vt
stde_50 = 0.05 #used in ep in equation of error e

v_t_50 = np.random.normal(0,1,[3,T])*stdv_50 #3 factor distribution #intialised as 3 x 180
beta_50 = c_ijt_50[:,[0,1,2]]

#betav
betav_50 = np.zeros((N*T,1)) # 36000 x 1
for t in range(T):
  ind = (time_50==t)
  betav_50[ind] = np.dot(beta_50[ind,:],v_t_50[:,t]).reshape(-1,1)

#ep
ep_50 = np.random.standard_t(5,[N*T,1])*stde_50

#Calculating error term
error_50 = betav_50 + ep_50

# Calculating returns
r1_50 =  g1_50 + error_50

# Saving it to directories
# pathz_50 = path1+'/z1_50'+'.csv'
# pathr1_50 = path1+'/r1_50'+'.csv'

dataframe_z_50 = pd.DataFrame(z_50)
dataframe_r1_50 = pd.DataFrame(r1_50)

# dataframe_z_50.to_csv(pathz_50, index=False)
# dataframe_r1_50.to_csv(pathr1_50, index=False)

"""**Model 2**:

$g^*(z_{i,t}) = (c_{i1,t}^2, c_{i1,t} × c_{i2,t}, sgn(c_{i3,t} × x_t)) θ_0$ where $θ_0 = (0.04, 0.03, 0.012)'$
"""

# Calculating z and making changes in all the three factors
z_50_2 = z_50.copy()
z_50_2[:,0] = np.square(c_ijt_50[:,0])*2
z_50_2[:,1] = np.multiply(c_ijt_50[:,0], c_ijt_50[:,1])*1.5
z_50_2[:,Pc_50+3-1] = np.sign(c_x_50[:,2])*0.6

#Calulating g2
g2_50 = np.dot(z_50_2,theta_50)

#Calculating returns
r2_50 = g2_50 + error_50

#Saving it to directories
# pathr2_50 = path1+'/r2_50'+'.csv'

dataframe_r2_50 = pd.DataFrame(r2_50)

# dataframe_r2_50.to_csv(pathr2_50, index=False)

"""**Note: In modelling, use z1 and r2**

### $\underline{Case Pc = 100 (Parameter)}$
"""

Pc_100 = 100 #No of characteristics or parameters

"""**Step 1: For Calculating $g^*(z_{i,t})$ we need to calculate the below terms**

$z_{i,t} = (1,x)' \otimes c_{i,t}$ 

$c_{i,j,t} = \frac{2}{N+1} CSrank(\overline{c}_{i,j,t})-1$

$x_t = \rho x_{t-1} + u_t$

Calculating $c_{i,j,t} = \frac{2}{N+1} CSrank(\overline{c}_{i,j,t})-1$, where $\overline{c}_{i,j,t} = \rho_j \overline{c}_{i,j,t-1} + \epsilon_{i,j,t}$ for $\rho_j\sim U[0.9,1]$ and $\epsilon_{i,j,t}\sim N(0,1-\rho_j^2)$
"""

c_ijt_100 = np.zeros((N*T,Pc_100)) # 36000 x 100; the matric c_i,j,t
rho_j_100 = np.random.uniform(0.9,1,[Pc_100,1]) # 100 x 1; used in the equation of cbar_i,j,t

#Calculating c_ijt
for j in range(Pc_100):
  cbar_ijt_100 = np.zeros((N,T)) # 200 x 180; cbar_i,j,t
  cbar_ijt_100[:, 0] = np.random.uniform(0,1,N) # cbar_i,j,0 is initialised to values between [0, 1]

  for t in range(1,T):
    cbar_ijt_100[:,t] = rho_j_100[j]*cbar_ijt_100[:,t-1] + np.random.normal(0,1,N)*math.sqrt(1-rho_j_100[j]**2) #filling column wise for all stocks

  cbar_ijt_normal_100 = np.zeros(cbar_ijt_100.shape) # 200 x 180 for the normalised values of the characteristics
  for t in range(cbar_ijt_100.shape[1]): # loop through 180 columns
    cbar_ijt_normal_100[:, t] = csrankf(cbar_ijt_100[:,t].tolist())* 2/(N+1)-1 
    
  c_ijt_100[:,j] = cbar_ijt_normal_100.flatten('F') #Final characteristic matrix

"""Calculating $x_t = \rho x_{t-1} + u_t$ for $\rho$ = 0.95 and $u_t \sim N(0,1-\rho^2)$"""

#calculating xt
rho_100 = 0.95
x_t_100 = np.zeros((T,1)) # 180 x 1; x_t is time series component and is highly persistent
x_t_100[0] = np.random.normal(0,1) #initiated with value between [0, 1]

for t in range(1,T):
  x_t_100[t] = rho_100 * x_t_100[t-1] + np.random.normal(0,1)*math.sqrt(1-rho_100**2)

"""Calculating $z_{i,t} = (1,x_t)' \otimes c_{i,t}$ """

# Calculating characteristics with time series common characteristics, c_x
c_x_100 = c_ijt_100
time_100 = np.repeat(np.arange(T), N) #(36000,1) time vector to fill sequentially in time

for t in range(T):
  idx = (time_100==t) #idx for all stocks observed at same month 
  c_x_100[idx,:] = c_ijt_100[idx, :]*x_t_100[t]

#Equivalent to tensor product, z is:
z_100 = np.hstack((c_ijt_100, c_x_100))

"""Calculating $g^*(z_{i,t})$

**Model 1**: 

$g^*(z_{i,t}) = (c_{i1,t}, c_{i2,t}, c_{i3,t} × x_t ) θ_0$ where $θ_0 = (0.02, 0.02, 0.02)'$
"""

# Calculating theta0
theta_w_100 = 0.02 #used in g* in equation to find return r
theta_nested_100 = [1.0, 1.0, np.repeat(0.0,Pc_100-2).tolist(), 0.0, 0.0, 1.0, np.repeat(0.0,Pc_100-3).tolist()] #1.0 corresponding to 3 factors
theta_100 = np.array(flattenNestedList(theta_nested_100))*theta_w_100
theta_100 = theta_100.reshape(-1,1) # 200 x 1

#Calculating g*
g1_100 = np.dot(z_100,theta_100)

"""**Step 2**: For calculating $e_{i,t+1} = β_{i,t}v_{t+1} + ε_{i,t+1}$

$β_{i,t} = (c_{i1,t}, c_{i2,t}, c_{i3,t})$

$v_{t+1} ∼ N (0,0.05^2 × I_3 )$ is a 3 × 1 vector of factors

$ε_{t+1} ∼ t_5 (0, 0.05^2)$ is a N × 1 vector of idiosyncratic errors
"""

stdv_100 = 0.05 #used in the equation of vt
stde_100 = 0.05 #used in ep in equation of error e

v_t_100 = np.random.normal(0,1,[3,T])*stdv_100 #3 factor distribution #intialised as 3 x 180
beta_100 = c_ijt_100[:,[0,1,2]]

#betav
betav_100 = np.zeros((N*T,1)) # 36000 x 1
for t in range(T):
  ind = (time_100==t)
  betav_100[ind] = np.dot(beta_100[ind,:],v_t_100[:,t]).reshape(-1,1)

#ep
ep_100 = np.random.standard_t(5,[N*T,1])*stde_100

#Calculating error term
error_100 = betav_100 + ep_100

# Calculating returns
r1_100 =  g1_100 + error_100

# Saving it to directories
# pathz_100 = path2+'/z_100'+'.csv'
# pathr1_100 = path2+'/r1_100'+'.csv'

dataframe_z_100 = pd.DataFrame(z_100)
dataframe_r1_100 = pd.DataFrame(r1_100)

# dataframe_z_100.to_csv(pathz_100, index=False) # 36000 x 200
# dataframe_r1_100.to_csv(pathr1_100, index=False)

"""**Model 2**:

$g^*(z_{i,t}) = (c_{i1,t}^2, c_{i1,t} × c_{i2,t}, sgn(c_{i3,t} × x_t)) θ_0$ where $θ_0 = (0.04, 0.03, 0.012)'$
"""

# Calculating z and making changes in all the three factors
z_100_2 = z_100.copy()
z_100_2[:,0] = np.square(c_ijt_100[:,0])*2
z_100_2[:,1] = np.multiply(c_ijt_100[:,0], c_ijt_100[:,1])*1.5
z_100_2[:,Pc_100+3-1] = np.sign(c_x_100[:,2])*0.6

#Calulating g2
g2_100 = np.dot(z_100_2,theta_100)

#Calculating returns
r2_100 = g2_100 + error_100

#Saving it to directories
# pathr2_100 = path2+'/r2_100'+'.csv'

dataframe_r2_100 = pd.DataFrame(r2_100)
# dataframe_r2_100.to_csv(pathr2_100, index=False)