# Copyright 2021-2022 Boris Shminke
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Vampire Wrapper
================
"""
from typing import Tuple

import pexpect


class VampireWrapper:
    """
    a wrapper around Vampire binary running in a manual clause selection mode

    >>> import sys
    >>> if sys.version_info.major == 3 and sys.version_info.minor >= 9:
    ...     from importlib.resources import files
    ... else:
    ...     from importlib_resources import files
    >>> import os
    >>> vampire_binary = os.path.join(
    ...     files("gym_saturation")
    ...     .joinpath(os.path.join("resources", "vampire-mock"))
    ... )
    >>> vampire = VampireWrapper(vampire_binary)
    >>> vampire.start("mock_folder", "mock_problem")
    (('passive', '1', 'this_is_a_test_case(test_constants) [input]'),)
    >>> vampire.pick_a_clause(1)
    (('passive', '2', '~this_is_a_test_case(test_constants) [input]'), ('new', '3', ' [subsumption resolution 1,2]'))
    """

    def __init__(self, binary_path: str):
        self.binary_path = binary_path
        self._proc = None

    def _get_stdout(self) -> Tuple[Tuple[str, int, str], ...]:
        if self._proc is not None:
            result: Tuple[Tuple[str, int, str], ...] = tuple()
            self._proc.expect(["Pick a clause:", pexpect.EOF])
            for line in self._proc.before.decode("utf-8").split("\r\n"):
                if line[:5] == "[SA] ":
                    result_type, result_body = line[5:].split(": ")
                    clause_number, clause = result_body.split(". ")
                    result = result + ((result_type, clause_number, clause),)
            return result
        raise ValueError("start solving a problem first!")

    def start(
        self, problem_filename: str, tptp_folder: str
    ) -> Tuple[Tuple[str, int, str], ...]:
        """
        start Vampire in a manual mode on a given problem
        time limit is one day, Vampire prints everything

        :param problem_filename: full path of a TPTP problem file
        :param tptp_folder: the root folder for TPTP library
        :returns: a sequence of action type, clause number and clause
        """
        self._proc = pexpect.spawn(
            f"{self.binary_path} --manual_cs on --show_everything on "
            + f"--time_limit 1D --include {tptp_folder} {problem_filename}"
        )
        return self._get_stdout()

    def pick_a_clause(
        self, clause_number: int
    ) -> Tuple[Tuple[str, int, str], ...]:
        """
        select a clause and get response from Vampire

        :param clause_number: a given clause order number
        :returns: a sequence of action type, clause number and clause
        """
        if self._proc is not None:
            self._proc.sendline(f"{clause_number}")
            return self._get_stdout()
        raise ValueError("start solving a problem first!")


# vampire = VampireWrapper(
#     "/home/boris/projects/gym-saturation/vampire/vampire_z3_rel_static_master_5921"
# )
# print(
#     vampire.start(
#         "/home/boris/projects/gym-saturation/gym_saturation/resources/TPTP-mock/Problems/TST/TST002-1.p",
#         "/home/boris/projects/gym-saturation/gym_saturation/resources/TPTP-mock",
#     )
# )
# for i in range(21):
#     print(vampire.pick_a_clause(i))
