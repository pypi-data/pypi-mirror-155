{"version":3,"file":"static/js/130.0ac37d4b.chunk.js","mappings":"oKAAO,IAEMA,EAAY,SAACC,GACxB,MAHiC,WAG1BA,EAAEC,MAAMC,KAAR,UACAF,EAAEC,MAAMC,KADR,YACgBF,EAAEG,WAAWD,MAChCF,EAAEC,MAAMC,O,0IC0FRE,EAAiB,GAEjBC,EAAY,GAIZC,EAAe,GAGfC,EAA4B,GAUlC,SAASC,EAAUC,GACjB,IAAMC,EAAmC,GAEzC,OADAD,EAAOE,SAAQ,SAACC,GAAD,OAAWA,EAAMD,SAAQ,SAACE,GAAD,OAAWH,GAAIX,EAAAA,EAAAA,GAAUc,IAASA,QACnEC,OAAOC,OAAOL,GAGhB,SAASM,EAAcC,EAA0BC,GACtD,IAAMC,EAAI,IAAIC,EAAAA,SAAAA,MAKVC,EAAkB,EAClBC,EApBc,IAqBdC,EArBc,IAsBdL,IACFG,EAAkBG,KAAKC,IAAIP,EAASQ,OAAOC,OAAQT,EAASU,QAAQD,QAAUtB,EAE9EiB,GADAC,EAAUM,KACUR,GAItBF,EAAEW,SAAS,CAACC,QAAS,KAAMR,QAAAA,EAASD,QAAAA,IACpCH,EAAEa,qBAAoB,iBAAO,MAE7B,IAAMC,EAAwB,GACxBC,EAA4C,GAElDjB,EAAYN,SAAQ,SAACwB,GACnBD,EAAeC,EAAGjC,OAAQ,KAE5Be,EAAYN,SAAQ,SAACwB,GAInB,IAAMC,EAASC,EAASF,EAAI,CAACG,EAAG,EAAGC,EAAG,IACtCpB,EAAEqB,QAAQL,EAAGjC,KAAM,CACjBuC,MAAOL,EAAOM,OAAOD,MACrBE,OAAQP,EAAOM,OAAOC,SAKxBR,EAAGT,OAAOf,SAAQ,SAACiC,GACjBA,EAAMC,UAAUlC,SAAQ,SAACmC,GACnBZ,EAAeY,EAAI7C,MAAMC,OAASgC,EAAeC,EAAGjC,QACtDiB,EAAE4B,QAAQ,CAACC,EAAGF,EAAI7C,MAAMC,KAAM+C,EAAGd,EAAGjC,MAAO,CAACgD,OAAQ,IAEpDjB,EAAMkB,KAAK,CACTC,KAAM,CACJC,MAAO,CAACf,EAAG,EAAGC,EAAG,GACjBe,OAAQR,EAAI7C,MAAMC,KAClBqD,SAAUT,EAAI3C,WAAWD,MAE3BsD,GAAI,CACFH,MAAO,CAACf,EAAG,EAAGC,EAAG,GACjBe,OAAQnB,EAAGjC,KACXqD,SAAUX,EAAMzC,WAAWD,kBAQvCkB,EAAAA,OAAaD,GAEb,IAAMsC,EAAoC,GACpCC,EAA6C,GACnDvC,EAAEwC,QAAQhD,SAAQ,SAAU2C,GAC1B,IAAMM,EAAOzC,EAAEyC,KAAKN,GACfM,IAGLF,EAAWJ,GAAUM,MAiFvB,IAAIC,EAAW,EACXC,EAAY,EAIhBhD,OAAOiD,KAAKL,GAAY/C,SAAQ,SAAC2C,GAC/B,IAAMM,EAAOF,EAAWJ,GAClBnB,EAAKlB,EAAY+C,MAAK,qBAAE9D,OAAmBoD,KACjD,GAAKnB,EAAL,CAIA,IAAMG,EAAIsB,EAAKtB,EAAIsB,EAAKnB,MAAQ,EAC1BF,EAAIqB,EAAKrB,EAAIqB,EAAKjB,OAAS,EACjCc,EAAIH,GAAUjB,EAASF,EAAI,CAACG,EAAAA,EAAGC,EAAAA,IAC/BsB,EAAWrC,KAAKC,IAAIoC,EAAUvB,EAAIsB,EAAKnB,OACvCqB,EAAYtC,KAAKC,IAAIqC,EAAWvB,EAAIqB,EAAKjB,YAK3CxB,EAAEc,QAAQtB,SAAQ,SAAUsD,GAC1B,IAAMC,EAAOjC,EAAM+B,MAAK,SAACG,GAAD,OAAOA,EAAEf,KAAKE,SAAWW,EAAEjB,GAAKmB,EAAEX,GAAGF,SAAWW,EAAEhB,KACpEmB,EAASjD,EAAEkD,KAAKJ,GAAGG,OACrBF,IACFA,EAAKd,KAAKC,MAAQe,EAAO,GACzBF,EAAKV,GAAGH,MAAQe,EAAOA,EAAOzC,OAAS,OAI3C,IAAM2C,EAAwB,CAC5BrC,MAAAA,EACA0B,MAAOF,EACPhB,MAAOoB,EAAWtC,EAClBoB,OAAQmB,EAAYxC,EACpBiD,OAAQ,MASV,OANIrD,IAGFoD,EAAOC,OAMX,SAA6BnC,EAAuBD,EAAed,GACjE,IAAMiD,EAAyB,CAC7BE,sBAAuB,CACrBlC,EAAG,EACHC,EAAG,EACHE,MAAOL,EAAOK,MAAQ,EACtBE,OAAQP,EAAOO,OAAS,GAE1BD,OAAQ,CACNJ,EAAG/B,EACHgC,EAAGhC,EAA4Bc,EAC/BoB,MAAOL,EAAOK,MAAQlC,IACtBoC,OAAQP,EAAOO,OAAyD,GAA/CpC,EAA4Bc,IAEvDoD,gBAAiBlE,GACjBmE,mBAAoB,GACpBhD,OAAQ,GACRE,QAAS,GACTiB,UAAW8B,EACTnE,EAAU2B,EAAGT,OAAOhB,KAAI,SAACkE,GAAD,OAAOA,EAAE/B,eAtOH,GAwO9BT,EAAOK,OAEToC,WAAYF,EACVnE,EAAU2B,EAAGP,QAAQlB,KAAI,SAACkE,GAAD,OAAOA,EAAEC,eAClCzC,EAAOO,OA5OuB,GA6O9BP,EAAOK,QAILqC,EAAiBR,EAAO5B,OAAOH,EAAI+B,EAAO5B,OAAOC,OAgCvD,OA9BAR,EAAGT,OAAOf,SAAQ,SAACiC,EAAOmC,GACxBT,EAAO5C,OAAOkB,EAAMzC,WAAWD,MAAQ,CACrCkC,OAAQ,CACNE,EAAGgC,EAAO5B,OAAOJ,EACjBC,EAAG+B,EAAO5B,OAAOH,EAAIwC,EAAM1E,EAAYA,EACvCoC,MAAO,EACPE,OAAQtC,GAEV2E,KAAM,CACJ1C,EAAGgC,EAAO5B,OAAOJ,EAAIhC,EACrBiC,EAAG+B,EAAO5B,OAAOH,EAAIwC,EAAM1E,EAAYA,QAK7C8B,EAAGP,QAAQjB,SAAQ,SAACsE,EAAQF,GAC1BT,EAAO1C,QAAQqD,EAAO9E,WAAWD,MAAQ,CACvCkC,OAAQ,CACNE,EAAGgC,EAAO5B,OAAOJ,EACjBC,EAAGuC,EAAiBC,EAAM1E,EAC1BoC,MAAO,EACPE,OAAQtC,GAEV2E,KAAM,CACJ1C,EAAGgC,EAAO5B,OAAOJ,EAAIhC,EACrBiC,EAAGuC,EAAiBC,EAAM1E,EAAYA,QAKrCiE,EApEWY,CAAoBZ,EAAQpD,EAAUG,IAGjDiD,EAoET,SAASK,EAA0BQ,EAAqB5C,EAAW6C,GAEjE,IACMC,EAAaD,EAAcE,IAC3BC,EAAU/D,KAAKC,IAAI,IAAK4D,EAAaF,EAAMxD,QAC3C6D,EAHQjF,GAGQiB,KAAKiE,IAAI,GAAIJ,EAAaF,EAAMxD,OAAS4D,GAAW,GACpEG,EAASH,EAAU,IAAM,GAAK,EAE9BjB,EAAqC,GAQ3C,OAPAa,EAAMxE,SAAQ,SAACgF,EAAMZ,GACnB,IAAMa,EAAiB,EAAKb,EAAM,EAAK,EACvCT,GAAOvE,EAAAA,EAAAA,GAAU4F,IAAS,CACxBrD,EAAGkD,EAAQT,EAAMQ,EACjBhD,EAAGA,EAAImD,EAASE,MAGbtB,EAGF,SAASjC,EAASF,EAAe0D,GAGtC,IAAIC,EAAOD,EAAKtD,EAEVwD,EAEF,GAEEC,EAAqB,SAACjB,EAAakB,GACvC,IAAMC,GA5TO,IAKK,GAuTmCD,GAAS,EACxD3D,EAAIuD,EAAKvD,EAxTG,GAwTiByC,EAAMmB,EACzC,MAAO,CACLlB,KAAM,CACJ1C,EAAGA,EAAIhC,EACPiC,EAAGuD,EAzTUzF,IA2Tf+B,OAAQ,CACNE,EAAAA,EACAC,EAAGuD,EACHrD,MAjUc,GAkUdE,OAAQtC,KAKR8F,EAAgB,WACpB,IAAM/D,EAA0C,CAC9C4C,KAAM,CAAC1C,EAAGuD,EAAKvD,EAAIhC,EAAciC,EAAGuD,EAtUrBzF,IAuUf+B,OAAQ,CACNE,EAAGuD,EAAKvD,EACRC,EAAGuD,EACHrD,MAAO,EACPE,OAAQtC,IAIZ,OADAyF,GAAQzF,EACD+B,GAGTD,EAAGT,OAAOf,SAAQ,SAACiC,EAAOmC,GACxBgB,EAAcnD,EAAMzC,WAAWD,MAC7BiC,EAAGT,OAAOC,OAtVc,EAuVpBqE,EAAmBjB,EAAK5C,EAAGT,OAAOC,QAClCwE,OAEJhE,EAAGT,OAAOC,OA1Vc,IA2V1BmE,GAAQzF,GAGV,IAAM+F,EAAoB,CACxB9D,EAAGuD,EAAKvD,EACRC,EAAGf,KAAKC,IAAIoE,EAAKtD,EAAGuD,EAlWP,GAmWbrD,MAvWa,IAwWbE,OAAQvC,IAGV0F,GAAQ1F,EAEJ+B,EAAGhC,WAAWkG,WAAW1E,QAAUQ,EAAGhC,WAAWmG,cACnDF,EAASzD,QA5WgB,GA6WzBmD,GA7WyB,IAgX3B,IAAMS,EAKF,GAYJ,OAVApE,EAAGP,QAAQjB,SAAQ,SAACsE,EAAQF,GAC1BwB,EAActB,EAAO9E,WAAWD,MAC9BiC,EAAGP,QAAQD,OArXa,EAsXpBqE,EAAmBjB,EAAK5C,EAAGP,QAAQD,QACnCwE,OAEJhE,EAAGP,QAAQD,OAzXa,IA0X1BmE,GAAQzF,GAGH,CACLqC,OAAQ,CACNJ,EAAGuD,EAAKvD,EAAI,EACZC,EAAGsD,EAAKtD,EAAI,EACZE,MAAO+D,IACP7D,OAAQmD,EAAOD,EAAKtD,EAAI,IAE1BJ,GAAIiE,EACJ1E,OAAQqE,EACRnE,QAAS2E,K,sBC1eE,SAASE,EAAkBC,EAAKC,IAClC,MAAPA,GAAeA,EAAMD,EAAI/E,UAAQgF,EAAMD,EAAI/E,QAE/C,IAAK,IAAI3B,EAAI,EAAG4G,EAAO,IAAIC,MAAMF,GAAM3G,EAAI2G,EAAK3G,IAC9C4G,EAAK5G,GAAK0G,EAAI1G,GAGhB,OAAO4G,E,uDCPM,SAASE,EAAiBC,GACvC,GAAsB,qBAAXC,QAAmD,MAAzBD,EAAKC,OAAOC,WAA2C,MAAtBF,EAAK,cAAuB,OAAOF,MAAMzD,KAAK2D,G,+HCGvG,SAASG,EAAmBR,GACzC,OCJa,SAA4BA,GACzC,GAAIG,MAAMM,QAAQT,GAAM,OAAO,EAAAU,EAAA,GAAiBV,GDGzC,CAAkBA,KAAQ,EAAAW,EAAA,GAAgBX,KAAQ,EAAAY,EAAA,GAA2BZ,IELvE,WACb,MAAM,IAAIa,UAAU,wIFIwE,K,oEGJ/E,SAASC,EAA4BC,EAAGC,GACrD,GAAKD,EAAL,CACA,GAAiB,kBAANA,EAAgB,OAAO,OAAiBA,EAAGC,GACtD,IAAIC,EAAI7G,OAAO8G,UAAUC,SAASC,KAAKL,GAAGM,MAAM,GAAI,GAEpD,MADU,WAANJ,GAAkBF,EAAEO,cAAaL,EAAIF,EAAEO,YAAY9H,MAC7C,QAANyH,GAAqB,QAANA,EAAoBd,MAAMzD,KAAKqE,GACxC,cAANE,GAAqB,2CAA2CM,KAAKN,IAAW,OAAiBF,EAAGC,QAAxG","sources":["../../core/src/app/titleOfIO.ts","../../core/src/graph/layout.ts","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"],"sourcesContent":["export const DEFAULT_RESULT_NAME = 'result';\n\nexport const titleOfIO = (i: {solid: {name: string}; definition: {name: string}}) => {\n  return i.solid.name !== DEFAULT_RESULT_NAME\n    ? `${i.solid.name}:${i.definition.name}`\n    : i.solid.name;\n};\n","import * as dagre from 'dagre';\n\nimport {titleOfIO} from '../app/titleOfIO';\n\nimport {IBounds, IPoint} from './common';\n\ntype OpLayoutEdgeSide = {\n  point: IPoint;\n  opName: string;\n  edgeName: string;\n};\n\nexport type OpLayoutEdge = {\n  from: OpLayoutEdgeSide;\n  to: OpLayoutEdgeSide;\n};\n\nexport interface OpLayout {\n  // Overall frame of the box relative to 0,0 on the graph\n  bounds: IBounds;\n\n  // Frames of specific components - These need to be computed during layout\n  // (rather than at render time) to position edges into inputs/outputs.\n  op: IBounds;\n  inputs: {\n    [inputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  };\n  outputs: {\n    [outputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  };\n}\n\nexport type OpGraphLayout = {\n  width: number;\n  height: number;\n  parent: ParentOpLayout | null;\n  edges: OpLayoutEdge[];\n  nodes: {[opName: string]: OpLayout};\n};\n\ninterface ParentOpLayout extends Omit<OpLayout, 'op'> {\n  mappingLeftEdge: number;\n  mappingLeftSpacing: number;\n  dependsOn: {[opName: string]: IPoint};\n  dependedBy: {[opName: string]: IPoint};\n  invocationBoundingBox: IBounds;\n}\n\nexport interface ILayoutOp {\n  name: string;\n  inputs: {\n    definition: {\n      name: string;\n    };\n    dependsOn: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n  definition: {\n    description: string | null;\n    assetNodes: {\n      assetKey: {\n        path: string[];\n      };\n    }[];\n  };\n  outputs: {\n    definition: {\n      name: string;\n    };\n    dependedBy: {\n      definition: {\n        name: string;\n      };\n      solid: {\n        name: string;\n      };\n    }[];\n  }[];\n}\n\nconst MAX_PER_ROW_ENABLED = false;\nconst MAX_PER_ROW = 25;\nconst OP_WIDTH = 370;\nconst OP_BASE_HEIGHT = 52;\nconst OP_ASSETS_ROW_HEIGHT = 22;\nconst IO_HEIGHT = 26;\nconst IO_INSET = 0;\nconst IO_MINI_WIDTH = 35;\nconst IO_THRESHOLD_FOR_MINI = 4;\nconst PORT_INSET_X = 13;\nconst PORT_INSET_Y = IO_HEIGHT / 2;\nconst PARENT_DEFINITION_PADDING = 70;\nconst PARENT_INVOCATION_PADDING = 70;\nconst EXTERNAL_DEPENDENCY_PADDING = 50;\n\nconst MARGIN_BASE = 100;\n\ntype OpLinkInfo = {\n  solid: {name: string};\n  definition: {name: string};\n};\n\nfunction flattenIO(arrays: OpLinkInfo[][]) {\n  const map: {[key: string]: OpLinkInfo} = {};\n  arrays.forEach((array) => array.forEach((item) => (map[titleOfIO(item)] = item)));\n  return Object.values(map);\n}\n\nexport function layoutOpGraph(pipelineOps: ILayoutOp[], parentOp?: ILayoutOp): OpGraphLayout {\n  const g = new dagre.graphlib.Graph();\n\n  // First, identify how much space we need to pad the DAG by in order to show the\n  // parent op AROUND it. We pass this padding in to dagre, and then we have enough\n  // room to add our parent layout around the result.\n  let parentIOPadding = 0;\n  let marginy = MARGIN_BASE;\n  let marginx = MARGIN_BASE;\n  if (parentOp) {\n    parentIOPadding = Math.max(parentOp.inputs.length, parentOp.outputs.length) * IO_HEIGHT;\n    marginx = PARENT_DEFINITION_PADDING + PARENT_INVOCATION_PADDING;\n    marginy = marginx + parentIOPadding;\n  }\n\n  // Define a new top-down, left to right graph layout\n  g.setGraph({rankdir: 'TB', marginx, marginy});\n  g.setDefaultEdgeLabel(() => ({}));\n\n  const edges: OpLayoutEdge[] = [];\n  const opNamesPresent: {[name: string]: boolean} = {};\n\n  pipelineOps.forEach((op) => {\n    opNamesPresent[op.name] = true;\n  });\n  pipelineOps.forEach((op) => {\n    // Lay out each op individually to get it's width and height based on it's\n    // inputs and outputs, and then attach it to the graph. Dagre will give us it's\n    // x,y position.\n    const layout = layoutOp(op, {x: 0, y: 0});\n    g.setNode(op.name, {\n      width: layout.bounds.width,\n      height: layout.bounds.height,\n    });\n\n    // Give Dagre the dependency edges and build a flat set of them so we\n    // can reference them in a single pass later\n    op.inputs.forEach((input) => {\n      input.dependsOn.forEach((dep) => {\n        if (opNamesPresent[dep.solid.name] && opNamesPresent[op.name]) {\n          g.setEdge({v: dep.solid.name, w: op.name}, {weight: 1});\n\n          edges.push({\n            from: {\n              point: {x: 0, y: 0},\n              opName: dep.solid.name,\n              edgeName: dep.definition.name,\n            },\n            to: {\n              point: {x: 0, y: 0},\n              opName: op.name,\n              edgeName: input.definition.name,\n            },\n          });\n        }\n      });\n    });\n  });\n\n  dagre.layout(g);\n\n  const ops: {[opName: string]: OpLayout} = {};\n  const dagreNodes: {[opName: string]: dagre.Node} = {};\n  g.nodes().forEach(function (opName) {\n    const node = g.node(opName);\n    if (!node) {\n      return;\n    }\n    dagreNodes[opName] = node;\n  });\n\n  if (MAX_PER_ROW_ENABLED) {\n    const nodesInRows: {[key: string]: dagre.Node[]} = {};\n    g.nodes().forEach(function (opName) {\n      const node = g.node(opName);\n      if (!node) {\n        return;\n      }\n      nodesInRows[`${node.y}`] = nodesInRows[`${node.y}`] || [];\n      nodesInRows[`${node.y}`].push(node);\n    });\n\n    // OK! We're going to split the nodes in long (>MAX_PER_ROW) rows into\n    // multiple rows, shift all the subsequent rows down. Note we do this\n    // repeatedly until each row has less than MAX_PER_ROW nodes. There are\n    // a few caveats to this:\n    // - We may end up making the lines betwee nodes and their children\n    //   less direct.\n    // - We may \"compact\" two groups of ops separated by horizontal\n    //   whitespace on the same row into the same block.\n\n    const rows = Object.keys(nodesInRows)\n      .map((a) => Number(a))\n      .sort((a, b) => a - b);\n\n    const firstRow = nodesInRows[`${rows[0]}`];\n    const firstRowCenterX = firstRow\n      ? firstRow.reduce((s, n) => s + n.x + n.width / 2, 0) / firstRow.length\n      : 0;\n\n    for (let ii = 0; ii < rows.length; ii++) {\n      const rowKey = `${rows[ii]}`;\n      const rowNodes = nodesInRows[rowKey];\n\n      const desiredCount = Math.ceil(rowNodes.length / MAX_PER_ROW);\n      if (desiredCount === 1) {\n        continue;\n      }\n\n      for (let r = 0; r < desiredCount; r++) {\n        const newRowNodes = rowNodes.slice(r * MAX_PER_ROW, (r + 1) * MAX_PER_ROW);\n        const maxHeight = Math.max(...newRowNodes.map((n) => n.height)) + OP_BASE_HEIGHT;\n        const totalWidth = newRowNodes.reduce((sum, n) => sum + n.width + OP_BASE_HEIGHT, 0);\n\n        let x = firstRowCenterX - totalWidth / 2;\n\n        // shift the nodes before the split point so they're centered nicely\n        newRowNodes.forEach((n) => {\n          n.x = x;\n          x += n.width + OP_BASE_HEIGHT;\n        });\n\n        // shift the nodes after the split point downwards\n        const shifted = rowNodes.slice((r + 1) * MAX_PER_ROW);\n        shifted.forEach((n) => (n.y += maxHeight));\n\n        // shift all nodes in the graph beneath this row down by\n        // the height of the newly inserted row.\n        const shiftedMaxHeight = Math.max(0, ...shifted.map((n) => n.height)) + OP_BASE_HEIGHT;\n\n        for (let jj = ii + 1; jj < rows.length; jj++) {\n          nodesInRows[`${rows[jj]}`].forEach((n) => (n.y += shiftedMaxHeight));\n        }\n      }\n    }\n    let minX = Number.MAX_SAFE_INTEGER;\n    Object.keys(dagreNodes).forEach((opName) => {\n      const node = dagreNodes[opName];\n      minX = Math.min(minX, node.x - node.width / 2 - marginx);\n    });\n    Object.keys(dagreNodes).forEach((opName) => {\n      const node = dagreNodes[opName];\n      node.x -= minX;\n    });\n  }\n\n  // Due to a bug in Dagre when run without an \"align\" value, we need to calculate\n  // the total width of the graph coordinate space ourselves. We need the height\n  // because we've shifted long single rows into multiple rows.\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  // Read the Dagre layout and map \"nodes\" back to our solids, but with\n  // X,Y coordinates this time.\n  Object.keys(dagreNodes).forEach((opName) => {\n    const node = dagreNodes[opName];\n    const op = pipelineOps.find(({name}) => name === opName);\n    if (!op) {\n      return;\n    }\n\n    const x = node.x - node.width / 2; // Dagre's x/y is the center, we want top left\n    const y = node.y - node.height / 2;\n    ops[opName] = layoutOp(op, {x, y});\n    maxWidth = Math.max(maxWidth, x + node.width);\n    maxHeight = Math.max(maxHeight, y + node.height);\n  });\n\n  // Read the Dagre layout and map \"edges\" back to our data model. We don't\n  // currently use the \"closest points on the node\" Dagre suggests (but we could).\n  g.edges().forEach(function (e) {\n    const conn = edges.find((c) => c.from.opName === e.v && c.to.opName === e.w);\n    const points = g.edge(e).points;\n    if (conn) {\n      conn.from.point = points[0];\n      conn.to.point = points[points.length - 1];\n    }\n  });\n\n  const result: OpGraphLayout = {\n    edges,\n    nodes: ops,\n    width: maxWidth + marginx,\n    height: maxHeight + marginy,\n    parent: null,\n  };\n\n  if (parentOp) {\n    // Now that we've computed the pipeline layout fully, lay out the\n    // composite op around the completed DAG.\n    result.parent = layoutParentGraphOp(result, parentOp, parentIOPadding);\n  }\n\n  return result;\n}\n\nfunction layoutParentGraphOp(layout: OpGraphLayout, op: ILayoutOp, parentIOPadding: number) {\n  const result: ParentOpLayout = {\n    invocationBoundingBox: {\n      x: 1,\n      y: 1,\n      width: layout.width - 1,\n      height: layout.height - 1,\n    },\n    bounds: {\n      x: PARENT_INVOCATION_PADDING,\n      y: PARENT_INVOCATION_PADDING + parentIOPadding,\n      width: layout.width - PARENT_INVOCATION_PADDING * 2,\n      height: layout.height - (PARENT_INVOCATION_PADDING + parentIOPadding) * 2,\n    },\n    mappingLeftEdge: PARENT_INVOCATION_PADDING - 20,\n    mappingLeftSpacing: 10,\n    inputs: {},\n    outputs: {},\n    dependsOn: layoutExternalConnections(\n      flattenIO(op.inputs.map((d) => d.dependsOn)),\n      -EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n    dependedBy: layoutExternalConnections(\n      flattenIO(op.outputs.map((d) => d.dependedBy)),\n      layout.height + EXTERNAL_DEPENDENCY_PADDING,\n      layout.width,\n    ),\n  };\n\n  const boundingBottom = result.bounds.y + result.bounds.height;\n\n  op.inputs.forEach((input, idx) => {\n    result.inputs[input.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: result.bounds.y - idx * IO_HEIGHT - IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  op.outputs.forEach((output, idx) => {\n    result.outputs[output.definition.name] = {\n      layout: {\n        x: result.bounds.x,\n        y: boundingBottom + idx * IO_HEIGHT,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n      port: {\n        x: result.bounds.x + PORT_INSET_X,\n        y: boundingBottom + idx * IO_HEIGHT + IO_HEIGHT / 2,\n      },\n    };\n  });\n\n  return result;\n}\n\nfunction layoutExternalConnections(links: OpLinkInfo[], y: number, layoutWidth: number) {\n  // fill evenly from 0 to layoutWidth from left to right, then center them if there's overflow.\n  const inset = PARENT_INVOCATION_PADDING + PORT_INSET_X;\n  const insetWidth = layoutWidth - inset * 2;\n  const spacing = Math.max(200, insetWidth / links.length);\n  const baseX = inset + Math.min(0, (insetWidth - links.length * spacing) / 2);\n  const yShift = spacing < 300 ? 20 : 0;\n\n  const result: {[opName: string]: IPoint} = {};\n  links.forEach((link, idx) => {\n    const shiftDirection = 1 - (idx % 2) * 2; // 1 or -1, alternating\n    result[titleOfIO(link)] = {\n      x: baseX + idx * spacing,\n      y: y + yShift * shiftDirection,\n    };\n  });\n  return result;\n}\n\nexport function layoutOp(op: ILayoutOp, root: IPoint): OpLayout {\n  // Starting at the root (top left) X,Y, return the layout information for a solid with\n  // input blocks, then the main block, then output blocks (arranged vertically)\n  let accY = root.y;\n\n  const inputsLayouts: {\n    [inputName: string]: {layout: IBounds; port: IPoint};\n  } = {};\n\n  const buildIOSmallLayout = (idx: number, count: number) => {\n    const centeringOffsetX = (OP_WIDTH - IO_MINI_WIDTH * count) / 2;\n    const x = root.x + IO_MINI_WIDTH * idx + centeringOffsetX;\n    return {\n      port: {\n        x: x + PORT_INSET_X,\n        y: accY + PORT_INSET_Y,\n      },\n      layout: {\n        x,\n        y: accY,\n        width: IO_MINI_WIDTH,\n        height: IO_HEIGHT,\n      },\n    };\n  };\n\n  const buildIOLayout = () => {\n    const layout: {layout: IBounds; port: IPoint} = {\n      port: {x: root.x + PORT_INSET_X, y: accY + PORT_INSET_Y},\n      layout: {\n        x: root.x,\n        y: accY,\n        width: 0,\n        height: IO_HEIGHT,\n      },\n    };\n    accY += IO_HEIGHT;\n    return layout;\n  };\n\n  op.inputs.forEach((input, idx) => {\n    inputsLayouts[input.definition.name] =\n      op.inputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.inputs.length)\n        : buildIOLayout();\n  });\n  if (op.inputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  const opLayout: IBounds = {\n    x: root.x,\n    y: Math.max(root.y, accY - IO_INSET),\n    width: OP_WIDTH,\n    height: OP_BASE_HEIGHT + IO_INSET * 2,\n  };\n\n  accY += OP_BASE_HEIGHT;\n\n  if (op.definition.assetNodes.length && op.definition.description) {\n    opLayout.height += OP_ASSETS_ROW_HEIGHT;\n    accY += OP_ASSETS_ROW_HEIGHT;\n  }\n\n  const outputLayouts: {\n    [outputName: string]: {\n      layout: IBounds;\n      port: IPoint;\n    };\n  } = {};\n\n  op.outputs.forEach((output, idx) => {\n    outputLayouts[output.definition.name] =\n      op.outputs.length > IO_THRESHOLD_FOR_MINI\n        ? buildIOSmallLayout(idx, op.outputs.length)\n        : buildIOLayout();\n  });\n  if (op.outputs.length > IO_THRESHOLD_FOR_MINI) {\n    accY += IO_HEIGHT;\n  }\n\n  return {\n    bounds: {\n      x: root.x - 5,\n      y: root.y - 5,\n      width: OP_WIDTH + 10,\n      height: accY - root.y + 10,\n    },\n    op: opLayout,\n    inputs: inputsLayouts,\n    outputs: outputLayouts,\n  };\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}"],"names":["titleOfIO","i","solid","name","definition","OP_BASE_HEIGHT","IO_HEIGHT","PORT_INSET_X","PARENT_INVOCATION_PADDING","flattenIO","arrays","map","forEach","array","item","Object","values","layoutOpGraph","pipelineOps","parentOp","g","dagre","parentIOPadding","marginy","marginx","Math","max","inputs","length","outputs","PARENT_DEFINITION_PADDING","setGraph","rankdir","setDefaultEdgeLabel","edges","opNamesPresent","op","layout","layoutOp","x","y","setNode","width","bounds","height","input","dependsOn","dep","setEdge","v","w","weight","push","from","point","opName","edgeName","to","ops","dagreNodes","nodes","node","maxWidth","maxHeight","keys","find","e","conn","c","points","edge","result","parent","invocationBoundingBox","mappingLeftEdge","mappingLeftSpacing","layoutExternalConnections","d","dependedBy","boundingBottom","idx","port","output","layoutParentGraphOp","links","layoutWidth","insetWidth","inset","spacing","baseX","min","yShift","link","shiftDirection","root","accY","inputsLayouts","buildIOSmallLayout","count","centeringOffsetX","buildIOLayout","opLayout","assetNodes","description","outputLayouts","OP_WIDTH","_arrayLikeToArray","arr","len","arr2","Array","_iterableToArray","iter","Symbol","iterator","_toConsumableArray","isArray","arrayLikeToArray","iterableToArray","unsupportedIterableToArray","TypeError","_unsupportedIterableToArray","o","minLen","n","prototype","toString","call","slice","constructor","test"],"sourceRoot":""}